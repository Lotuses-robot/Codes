还有一些细节，前缀和的处理。不能每次枚举的时候手算前缀和，否则这样会出 $O(n^2)$。

在开始的时候，预算出 $s'_i$，排序后，计算 $f_{1\sim n}$（这里可以 $O(n)$ 吧 先预算出 $f_1$，后面每次移动量 $\Delta s'$ 对应 $\Delta f = (2i-2-n)\Delta s'$ 即 $f_{i} = f_{i - 1} + (2i-2-n)\cdot (s_i - s_{i - 1})$。

重新堆 $f_i$ 整理顺序，按照原来的顺序排序。

预处理出 $f_i$ 后，每次选取一个 $i$ 作为插入点，就是在第 $i$ 个点后面插入一个 $q_{i + 1}$。

那么将影响的所有 $f_j$。
$$
f_j \to f_j + (n - i)\cdot q_{i + 1}\ (j \le i)\\
f_j \to f_j + i\cdot q_{i+1}\ (j > i)
$$


对 $f$ 做 st 表，每次查询以 $i$ 做分割的两个子部分，分别对两部分的最大值增加这些贡献。

最后将两个最大值一取大，就是对应的 $i$ 的答案。

还有个问题，最后加入的 $f_i$ 并没有计算！因为只计算了前后，所以没有计算。

于是拿出刚刚排完序的 $s_i$。寻找一个 $s_j \le s_i' + q_{i + 1}$，利用刚刚位移的方法，$f_i = f_j + (2i - 1 - n) \cdot (s_i' + q_{i + 1} - s_j)$ 只是这里的 $n$ 加了 $1$。

最后再取一次最大值，就 $\text{OK}$ 了！！！

那么就可以 $O(n)$ 解决。（只需要枚举 $i$ 的取值）。