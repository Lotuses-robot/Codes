## color

### sub1

$\text{n}\leq 4$ 直接枚举每个集合的颜色，求最小值，复杂度$\text{O}(2^{2^\text{n}}2^\text{n})$

### sub2

设 `dp[s][0]`，表示 `s`染成白色和 `s`的子集的最小代价，`dp[s][1]`，表示 `s`染成黑色和 `s`的子集的最小代价，

考虑白色，黑色同理，

若 `s`存在一个子集 `t`，且 `t`为黑色，则对于其它任意包含$\text{s}-\text{t}$的集合都是白色的，枚举这个子集 `t`，

得到转移式 $\text{dp[s][0]}=\min\limits_{\text{t}\in \text{s}} \text{dp[t][1]}+\text{sum}(\text{s}-\text{t},0)$，复杂度$\text{O}(3^\text{n})$

### sub3

考虑一个性质，若 `s`是白色，则必然存在一个元素 `x`，使得所有包含 `x`的集合都是白色的。

这个性质用逆命题显然成立。

所以我们可以枚举 `x`，得到转移式 $\text{dp[s][0]}=\min\limits_{x \in s}\min(\text{dp[s-x][0],dp[s-x][1]}+\text{sum'}(\text{s-x,}0))$

`sum'(s,0)`表示 `s`的所有子集都染成白色的代价，这个可以用高维前缀和搞定。

所以复杂度$\text{O}(2^\text{n}\text{n})$

## 大撒大撒

现在考虑 $|i-j|=|a_i-a_j|$ ，这个式子可以拆分成 $i+a_i=j+a_j$ 或者 $i-a_i=j-a_j$ 。

我们观察到二选一的这个性质，可以这样转化这个问题：

有一个二分图，其中左右两边都有一些点。原来的第 $i$ 个点，转化为一条边，由左侧的 $i-a_i$ 号点连向右侧的 $i+a_i$ 号点。

问题转化为了，每一条边选择给它的一个端点的权值加上 $1$ ，最后要求所有点的权值皆为偶数（每一个新点的边两两配对，且一条边只能用一次）

也可以这么说：每一条边选择给它的一个端点权值异或 $1$ ，最后要求所有点的权值为 $0$ 。

这是一个经典问题，我们可以轻松把图给建出来，对于每一个连通块，它能成功匹配的必要条件是有偶数条边。

对于初始的任意一条边，我们随便给他的一个端点异或上一个 $1$ ，那么操作就转化为了同时给两个端点异或 $1$ 。

然后对于一个连通块，随便找一棵生成树，自底向上贪心构造就可以得到最后的解。

## 3123阿斯顿发放

事实上只需要考虑维护两个这样的数据结构：

1.支持单点加，整体加 $1$，单点查询，合并。

2.支持整体加 $1$，删除某个值，增加某个值，查询异或和。

第一个数据结构显然可以用线段树来维护，合并可以直接使用线段树合并。

第二个数据结构我们先观察整体  对异或和的影响。

对于一个末尾有连续 $a$ 个 $1$ 的二进制数，$+1$ 就相当于给这个二进制数的末尾异或上了 $a+1$ 个 $1$ ，所以我们只需要维护出末尾有 $0,1,2,...,30$ 个 $1$ 的二进制数的个数，我们就可以快速算出整体 $+1$ 对于异或和的影响。考虑将每个数的二进制倒着插入一个 $Trie$，也就是将最低位放在第一层，以此类推。

删除增加很好做，直接上即可。

怎么进行整体 $+1$ ，从根节点开始，交换 $01$ 两条边对应的子树，然后再跳到 $0$ 子树 $+1$ 即可。

为什么？因为末尾为 $0$ 的 $+1$ 就会变为末尾为 $1$ 的，末尾为 $1$ 的 $+1$ 就会向前进 $1$，并把这位变成 $0$，操作时间复杂度显然是 $\log$ 的。

末尾有 0,1,2,..,30 个 1 的二进制数个数也可以不断往 1 子树跳求出，操作时间复杂度也是 $\log n$。

因此这个算法的时间复杂度就是 $q\log \max{a_i}$。

因为可以离线，所以可以选择将第一个数据结构在求出 $Kruskal$ 重构树之后改为树状数组，然后用并查集来维护实时区间的左右端点即可。
